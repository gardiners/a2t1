---
title: "Untitled"
author: "Your name"
date: 
output:
  bookdown::pdf_document2:
    toc: TRUE
    number_sections: FALSE
  bookdown::html_document2: 
documentclass: article
classoption: a4paper
header-includes:
  - \usepackage[margin = 8pt]{subfig}
  - \captionsetup[figure]{labelfont={bf},textfont={it}}
  - \captionsetup[table]{labelfont={bf},textfont={it}}
  - \usepackage[a4paper,left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = "center")
```

# Preamble

```{r preamble-packages}
library(tidyverse)
```

```{r, echo = FALSE}
nicetab <- partial(knitr::kable,
                   linesep = "",
                   digits = 3,
                   booktabs = TRUE)
```

# Question 1

## (a)

```{bash}

```

# Question 2

## (a)

Download the database dump tarball:

```{bash}
curl -o world_x-db.tar.gz https://downloads.mysql.com/docs/world_x-db.tar.gz
```



Extract the tarball contents:

```{bash}
tar -xzvf world_x-db.tar.gz
```

Here,  `-x` is to to specify the extraction operation; `-z` specifies that the tarball is compressed with `gzip`; `-v` asks for verbose output and `-f` specifies the path to the tarball.

Since the data dump contains the SQL statements required to create the world_x database and its tables, we can use it as input to the `mysql` shell. Load the data dump as the superuser, and then grant access to our existing (less priviliged) user `awkologist`:

```{bash eval=FALSE}
sudo mysql < world_x-db/world_x.sql
sudo mysql world_x -e 'GRANT ALL ON world_x TO "awkologist" IDENTIFIED BY "awkology";'
```

Now as `awkologist`, verify that the new database exists and list its tables:

```{bash eval = FALSE}
mysql -u awkologist -p world_x -e "SHOW TABLES;"
```

````
## Enter password: 
## +-------------------+
## | Tables_in_world_x |
## +-------------------+
## | city              |
## | country           |
## | countryinfo       |
## | countrylanguage   |
## +-------------------+
````

## (b)

By examining the `CREATE TABLE` statements in the SQL data dump for `world_x` and by running `DESCRIBE` for each table, we can derive the relationships between the tables. These are represented graphically at Figure \@ref(fig:uml). Interestingly, `countryLanguage` has a compound primary key.


```{r uml, out.width="70%", echo = FALSE, fig.cap="UML graphical representation of \\texttt{world\\_x} database structure, excluding the JSON table \\texttt{countryinfo}."}
knitr::include_graphics("UML.pdf")
```

Since our class of interest for answering the question is `country`, we can peform a three-way inner join to combine all three tables. The `country.Code` $\leftrightarrow$ `city.CountryCode` foreign key relationship is not required to solve the problem; however, we do need the `country.Code` $\leftrightarrow$ `countryLanguage.CountryCode` and the `country.Capital` $\leftrightarrow$ `city.ID` foreign key relationships.

Once we have the joined table, we filter by a `WHERE` clause with the conditions that `countryLanguage.Language` is `English` and the `countryLanguage.Percentage` is over 50.

With that in mind, we formulate the following query and execute it against our database `world_x`:

```{sql eval = FALSE}
SELECT
  c.Name Country,
  l.Percentage,
  a.Name Capital
FROM countrylanguage l
INNER JOIN country c ON l.CountryCode = c.Code
INNER JOIN city a ON c.Capital = a.ID
WHERE
  l.Language = "English"
  AND l.Percentage > 50;
```

which yields the following result:

````
+----------------------+------------+------------------+
| Country              | Percentage | Capital          |
+----------------------+------------+------------------+
| Australia            |       81.2 | Canberra         |
| Belize               |       50.8 | Belmopan         |
| Bermuda              |      100.0 | Hamilton         |
| Canada               |       60.4 | Ottawa           |
| United Kingdom       |       97.3 | London           |
| Gibraltar            |       88.9 | Gibraltar        |
| Ireland              |       98.4 | Dublin           |
| New Zealand          |       87.0 | Wellington       |
| Trinidad and Tobago  |       93.5 | Port-of-Spain    |
| United States        |       86.2 | Washington       |
| Virgin Islands, U.S. |       81.7 | Charlotte Amalie |
+----------------------+------------+------------------+
````

# Question 3

To reproduce the plot we require information on COVID-19 deaths, and information on country populations. For the former, Johns Hopkins University publish daily COVID-19 case and mortality data [@Dong2020], available on GitHub at https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv. For the latter, the the World Bank Development Indicator estimates [@WorldBank2020] are available on GitHub at https://github.com/datasets/population.

We load `ggplot` and the rest of the `tidyverse`

```{r}
library(tidyverse)
```

then obtain the data:

```{r popdata, cache = TRUE}
# Read the World Bank population dataset:
pop <- read_csv("https://raw.githubusercontent.com/datasets/population/master/data/population.csv")

# Read the JHU COVID-19 deaths dataset.
covid_wide <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv")
```


Some cleaning is required: we choose to examine only the 25 April 2020 death data from JHU (to match the example plot), and to combine the sub-region death totals per country (ie combine states and provinces so that we have only a country total).

```{r}
covid_latest <- covid_wide %>%
  select(Country = `Country/Region`,  # Rename variables to meet R conventions.
         Region = `Province/State`,
         Deaths = `4/25/20`) %>%      # Select only today's totals column.
  group_by(Country) %>%               # Aggregate over entire countries.
  summarise(n = sum(Deaths))

glimpse(covid_latest)                 # Examine.
```

To prepare the World Bank data, we retain only the latest population data for each country.

```{r}
pop_latest <- pop %>%               
  group_by(`Country Code`) %>%       # Retain only the largest year's data
  top_n(1, Year)                     # for each country in the dataset.

glimpse(pop_latest)                  # Examine.
```

Having prepared our datasets, we can join them. We perform a left join on the JHU COVID-10 dataset, so we only preserve country population data for countries which have COVID-19 death data - this eliminates the country groups and leagues from the World Bank dataset. We compute the deaths per 100,000 population.

```{r}
deaths <- covid_latest %>%
  left_join(pop_latest, by = c("Country" = "Country Name")) %>% # Join on country name
  transmute(Country = Country,
            Deaths = n,
            Population = Value,
            Deaths_per_100k = Deaths / Population * 1e5)

glimpse(deaths)
```

Finally, we choose which countries we wish to plot, and filter our `deaths` dataset by these. We have elected to use all of the countries presented the in example, as well as Australia and Germany.

```{r}
countries <- c( "Australia", "Belgium", "Spain", "Italy", "France",
                "Netherlands", "Sweden", "Ireland", "Switzerland",
                "Portugal", "Denmark", "Germany", "Austria")

deaths_subset <- deaths %>%
  filter(Country %in% countries) %>%
  mutate(Country = factor(Country,
                          levels = arrange(., Deaths_per_100k)$Country))
```

We are now able to reproduce the plot:

```{r}
ggplot(deaths_subset, aes(Deaths_per_100k, Country)) +
  geom_bar(stat = "identity", width = 0.6, fill = "deepskyblue4") +
  labs(x = NULL, y = NULL,
       title = "German efficiency\nCovid-19 deaths per 100,000 population",
       subtitle = "Selected European countries and Australia, to April 25th 2020",
       caption = "Sources: Johns Hopkins University; World Bank") +
  theme_minimal() +
  theme(axis.text.y = element_text(hjust = 0),
        axis.line.y.left = element_line(colour = "black"),
        axis.text.x.top = element_text(),
        panel.grid.major.y = element_blank(),
        panel.grid.major.x = element_line(size = 1, colour = "grey"),
        plot.caption = element_text(hjust = 0, colour = "slategrey"),
        plot.caption.position = "plot",
        plot.title.position = "plot") +
  scale_x_continuous(breaks = seq(0, 60, 10),
                     minor_breaks = NULL,
                     position = "top",
                     expand = c(0, 0))
```



# References

